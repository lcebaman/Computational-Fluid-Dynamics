#include "helper.h"
#include "visual.h"
#include <math.h>
#include <stdio.h>


void write_vtkFile( const char *szProblem,
  int timeStepNumber,
	double xlength,
  double ylength, 
  double x_origin,
  double y_origin,
  int num_inner_particles,
  int num_boundary_particles,
	double dx,
	double dy,
  struct particle* domainparticles,
  int temp)
  {
  
  char szFileName[80];
  FILE *fp=NULL;
  sprintf( szFileName, "%s.%i.vtk", szProblem, timeStepNumber );  
  fp = fopen( szFileName, "w");
  if( fp == NULL )		       
  {
    char szBuff[80];
    sprintf( szBuff, "Failed to open %s", szFileName );
    ERROR( szBuff );
    return;
  }

  write_vtkHeader( fp, num_inner_particles, num_boundary_particles, dx, dy,xlength,ylength, temp);
  write_vtkPointCoordinates(fp, num_inner_particles, num_boundary_particles , dx, dy,domainparticles,temp);

  if(temp==1)//Heat plate problem
  {
    fprintf(fp,"\n");
    fprintf(fp,"POINT_DATA %i \n", num_inner_particles );
    fprintf(fp, "SCALARS Temperature float \n"); 
    fprintf(fp, "LOOKUP_TABLE default \n");

    for(int i = 0; i < num_inner_particles ; i++)
    {
      fprintf(fp, "%f\n", domainparticles[i].temperature );
    }

  }

  else if (temp==5) //For Lid driven problem with 9 particles visualisation
  {
    
    fprintf(fp,"\n");
    fprintf(fp,"POINT_DATA %i \n", 9 );
    fprintf(fp, "VECTORS velocity float\n");
    
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +2].u_vel , domainparticles[(num_inner_particles/2) +2].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +3].u_vel , domainparticles[(num_inner_particles/2) +3].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +4].u_vel , domainparticles[(num_inner_particles/2) +4].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +22].u_vel , domainparticles[(num_inner_particles/2) +22].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +23].u_vel , domainparticles[(num_inner_particles/2) +23].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +24].u_vel , domainparticles[(num_inner_particles/2) +24].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +42].u_vel , domainparticles[(num_inner_particles/2) +42].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +43].u_vel , domainparticles[(num_inner_particles/2) +43].v_vel);
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +44].u_vel , domainparticles[(num_inner_particles/2) +44].v_vel);
    
    fprintf(fp, "SCALARS pressure float \n"); 
    fprintf(fp, "LOOKUP_TABLE default \n");
    
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +2].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +3].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +4].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +22].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +23].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +24].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +42].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +43].pressure );
    fprintf(fp, "%f\n", domainparticles[(num_inner_particles/2) +44].pressure );
  }

  else //For all particles
  {
    fprintf(fp,"\n");
    fprintf(fp,"POINT_DATA %i \n", num_inner_particles );
    fprintf(fp, "VECTORS velocity float\n");
    
    for(int i = 0; i < num_inner_particles ; i++)
    {
        fprintf(fp, "%f %f 0\n", domainparticles[i].u_vel , domainparticles[i].v_vel);
    }
      
    fprintf(fp, "SCALARS pressure float \n"); 
    fprintf(fp, "LOOKUP_TABLE default \n");
     
    for(int i = 0; i <num_inner_particles; i++)
    {
        fprintf(fp, "%f\n", domainparticles[i].pressure );
    }
  }
  
  if( fclose(fp) )
  {
    char szBuff[80];
    sprintf( szBuff, "Failed to close %s", szFileName );
    ERROR( szBuff );
  }
}


void write_vtkHeader( FILE *fp, int num_inner_particles, int num_boundary_particles,
                      double dx, double dy,double x_length, double y_length, int temp) {
  if( fp == NULL )		       
  {
    char szBuff[80];
    sprintf( szBuff, "Null pointer in write_vtkHeader" );
    ERROR( szBuff );
    return;
  }

  fprintf(fp,"# vtk DataFile Version 2.0\n");
  fprintf(fp,"generated by CFD-lab project output (written by Ashish Darekar) \n");
  fprintf(fp,"ASCII\n");
  fprintf(fp,"DATASET POLYDATA\n");
  if(temp==1)
  {
    fprintf(fp,"POINTS %i FLOAT",num_inner_particles);
    
  }
  else if(temp==5) //For Lid driven problem with 9 particles visualisation
  {
    fprintf(fp,"POINTS %i FLOAT",9);
  }
  else //for lid driven For all particles
  {
    fprintf(fp,"POINTS %i FLOAT",num_inner_particles);
  }
  
  

}

void write_vtkPointCoordinates( FILE *fp, int num_inner_particles, int num_boundary_particles,
                      double dx, double dy, struct particle* domainparticles, int temp) {
  fprintf(fp,"\n");
  
  if(temp==1)  //For inner particles temperature problem
  {
    for(int i=0;i<num_inner_particles;i++) 
    {
      fprintf(fp, "%f %f 0\n", domainparticles[i].x_coordinate, domainparticles[i].y_coordinate );
    }
  }

  else if(temp==5) //For Lid driven problem with 9 particles visualisation
  {
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +2].x_coordinate, domainparticles[(num_inner_particles/2) +2].y_coordinate );
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +3].x_coordinate, domainparticles[(num_inner_particles/2) +3].y_coordinate ); 
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +4].x_coordinate, domainparticles[(num_inner_particles/2) +4].y_coordinate );   
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +22].x_coordinate, domainparticles[(num_inner_particles/2) +22].y_coordinate );
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +23].x_coordinate, domainparticles[(num_inner_particles/2) +23].y_coordinate ); 
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +24].x_coordinate, domainparticles[(num_inner_particles/2) +24].y_coordinate );  
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +42].x_coordinate, domainparticles[(num_inner_particles/2) +42].y_coordinate );
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +43].x_coordinate, domainparticles[(num_inner_particles/2) +43].y_coordinate ); 
    fprintf(fp, "%f %f 0\n", domainparticles[(num_inner_particles/2) +44].x_coordinate, domainparticles[(num_inner_particles/2) +44].y_coordinate );      
  }

  else //for lid driven For all particles
  {
    for(int i=0;i<num_inner_particles;i++) 
    {
      fprintf(fp, "%f %f 0\n", domainparticles[i].x_coordinate, domainparticles[i].y_coordinate );
    }
  }
  
  
 
}


